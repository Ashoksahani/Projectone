let verifyStream = require("./lib/verify");
let signStream = require("./lib/sign");
const Buffer = require("buffer").Buffer;
const util = require("util");

let TOKEN_ERROR = "JPT is invalid or expired"
let TOKEN_EXPIRED = "JPT expired"
let SECRET_ERROR = "secret must be 32bit long and string";
let IV_ERROR = "iv must be 16bit long and string"
let PAYLOAD_ERROR = "payload should be object";
let PASSWORD_SECRET_ERROR = "password secret length must be 10 or must be string";
let PASSWORD_ERROR = "password should be string"
let EXPIRYTIMEFORMAT_ERROR = "Expiry time format error, should be [5,'day/minute']"

function checkPayloadBufferOrString(payload) {
    return Buffer.isBuffer(payload) || typeof payload == "string";
}

function fromBase64(base64) {
    return base64
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function validTokenSecret(secret) {
    if (typeof secret == "string" && secret.length == 32) {
        return true;
    } else {
        throw buildError(SECRET_ERROR)
    }
}

function validIv(iv) {
    if (typeof iv == "string" && iv.length == 16) {
        return true;
    } else {
        throw buildError(IV_ERROR)
    }
}

function validPasswordSecret(secret) {
    if (typeof secret == "string" && secret.length == 10) {
        return true;
    } else {
        throw buildError(PASSWORD_SECRET_ERROR)
    }
}

function validPassword(password) {
    if (typeof password == "string") {
        return true;
    } else {
        throw buildError(PASSWORD_ERROR)
    }
}

function buildError(error) {
    let args = [].slice.call(arguments, 1);
    let errMsg = util.format.bind(util, error).apply(null, args);
    return new TypeError(errMsg);
}

function parseString(payload) {
    if (!checkPayloadBufferOrString(payload)) {
        payload = JSON.stringify(payload)
    }
    return payload
}

function isValidExp(expiryTime) {
    if (Array.isArray(expiryTime) && expiryTime.length == 2) {
        let timedigit = expiryTime[0]
        let schedule = expiryTime[1]
        if (typeof timedigit == "string" || typeof timedigit == "object" || typeof schedule != "string") {
            throw buildError(EXPIRYTIMEFORMAT_ERROR)
        } else {
            if (schedule == "day" || schedule == "minute") {
                return true
            } else {
                throw buildError(EXPIRYTIMEFORMAT_ERROR)
            }
        }
    } else {
        throw buildError(EXPIRYTIMEFORMAT_ERROR)
    }
}

function isValidPayload(payload) {
    if (typeof payload != "object" || Array.isArray(payload)) {
        throw buildError(PAYLOAD_ERROR)
    } else {
        return;
    }
}

function base64url(string, encoding) {
    return Buffer
        .from(string, encoding)
        .toString('base64')
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
}

function jptSecuredInput(payload, encoding) {
    encoding = encoding || 'utf8';
    var encodedPayload = base64url(JSON.stringify(payload), encoding);
    return util.format('%s', encodedPayload);
}

function convertExpiryTime(expiryTime) {
    let timedigit = expiryTime[0]
    let schedule = expiryTime[1]
    let modTime = new Date();
    if (schedule == 'day') {
        modTime.setDate(modTime.getDate() + timedigit);

    }
    if (schedule == "minute") {
        modTime.setMinutes(modTime.getMinutes() + timedigit);

    }
    modTime = modTime.getTime()
    return modTime
}

function encryptPass(secret, password) {
    validPasswordSecret(secret);
    validPassword(password)
    return signStream.setPassword(secret, password)
}

function isTimeExpire(time) {
    let expiredTime = new Date(time).getTime();
    return expiredTime < new Date().getTime();
}

function verifyPass(secret, hash, password) {
    validPasswordSecret(secret);
    validPassword(password);
    return verifyStream.verifyPassword(secret, hash, password)
}

function getSignatureFromPayload(payload, secret) {
    let signature = signStream.signsession(secret, payload);
    return fromBase64(signature)
}

function sign(payload = {}, secret, expiryTime = [7, 'day'], iv) {
    isValidExp(expiryTime);
    validTokenSecret(secret);
    validIv(iv)
    isValidPayload(payload);
    let expT = convertExpiryTime(expiryTime)
    payload.expT = parseInt(expT)
    payload = parseString(payload);
    let securedInput = jptSecuredInput(payload)
    let securedEncryptedInput = signStream.encrypt(securedInput, secret, iv)
    let signature = signStream.signsession(secret, payload);
    return util.format('%s.%s', securedEncryptedInput, fromBase64(signature))
}

function verify(token, secret, iv) {
    try {
        validTokenSecret(secret);
        validIv(iv)
        var payload = token.split('.')[0];
        var tokenSig = token.split('.')[1]
        let decryptedPayloadSig = verifyStream.decrypt(payload, secret, iv)
        let decryptedpayload = JSON.parse(Buffer.from(decryptedPayloadSig, 'base64').toString('utf8'), "utf8");
        let verified = tokenSig == getSignatureFromPayload(decryptedpayload, secret)
        if (!verified) {
            throw buildError(TOKEN_ERROR)
        } else {
            let decryptedData = JSON.parse(decryptedpayload)
            if (isTimeExpire(decryptedData.expT)) {
                throw buildError(TOKEN_EXPIRED)
            } else {
                delete decryptedData.expT
                return { decryptedData, verified }
            }

        }
    } catch (error) {
        throw buildError(TOKEN_ERROR)
    }
}

module.exports = {
    encryptPass,
    verifyPass,
    sign,
    verify
}